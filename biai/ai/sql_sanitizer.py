"""Helpers for sanitizing SQL generated by LLMs."""

from __future__ import annotations

import re

_SQL_START_RE = re.compile(r"\b(SELECT|WITH)\b", re.IGNORECASE)
_SQL_TAG_RE = re.compile(r"</?\s*sql\s*>", re.IGNORECASE)
_PREFIX_RE = re.compile(r"^\s*(sql|query|answer)\s*:\s*", re.IGNORECASE)
_FENCE_RE = re.compile(r"```(?:sql)?\s*(.*?)```", re.IGNORECASE | re.DOTALL)


def sanitize_generated_sql(raw: str) -> str:
    """Clean noisy model output and extract a single SQL statement."""
    if not raw:
        return ""

    text = raw.strip()
    fenced_blocks = _FENCE_RE.findall(text)
    if fenced_blocks:
        text = _pick_fenced_sql(fenced_blocks)

    text = _SQL_TAG_RE.sub(" ", text)
    text = _PREFIX_RE.sub("", text)
    text = text.replace("\r", " ").replace("\n", " ")
    text = re.sub(r"\s+", " ", text).strip()

    match = _SQL_START_RE.search(text)
    if match:
        text = text[match.start():]
    elif " from " in f" {text.lower()} ":
        # LLM sometimes returns fragments like "'X', COUNT(*) FROM table"
        text = f"SELECT {text}"

    if ";" in text:
        text = text.split(";", 1)[0]

    text = text.strip("` ").strip()
    text = re.sub(r"</?\w+[^>]*>", " ", text)
    text = re.sub(r"\s+", " ", text).strip()
    return text


def _pick_fenced_sql(blocks: list[str]) -> str:
    """Choose the most SQL-like fenced block."""
    for block in blocks:
        if _SQL_START_RE.search(block):
            return block.strip()
    return blocks[0].strip()
